



uuidrev                                                      K. R. Davis
Internet-Draft                                             Cisco Systems
Updates: 9562 (if approved)                               27 August 2024
Intended status: Standards Track                                        
Expires: 28 February 2025


             Longer Universally Unique IDentifiers (UUIDs)
                     draft-davis-uuidrev-uuid-long

Abstract

   This document extends Universally Unique Identifiers (UUIDs) beyond
   128 bits to facilitate enhanced collision resistance and proper room
   for embedding additional data within a given UUID algorithm.  These
   longer variable-length UUIDs ("UUID Long") leverage a previously
   unused variant bit "F" and feature a new sub-typing mechanisms
   created to ensure there is enough space to define many future UUID
   algorithms within this new variant of UUIDs.

   This document updates [RFC9562].

About This Document

   This note is to be removed before publishing as an RFC.

   The latest revision of this draft can be found at
   https://example.com/LATEST.  Status information for this document may
   be found at https://datatracker.ietf.org/doc/draft-davis-uuidrev-
   uuid/.

   Discussion of this document takes place on the Revise Universally
   Unique Identifier Definitions (uuidrev) Working Group mailing list
   (mailto:uuidrev@ietf.org), which is archived at
   https://mailarchive.ietf.org/arch/browse/uuidrev/.  Subscribe at
   https://www.ietf.org/mailman/listinfo/uuidrev/.

   Source for this draft and an issue tracker can be found at
   https://github.com/user/repo.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.







Davis                   Expires 28 February 2025                [Page 1]

Internet-Draft                  UUID Long                    August 2024


   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at https://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on 28 February 2025.

Copyright Notice

   Copyright (c) 2024 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents (https://trustee.ietf.org/
   license-info) in effect on the date of publication of this document.
   Please review these documents carefully, as they describe your rights
   and restrictions with respect to this document.  Code Components
   extracted from this document must include Revised BSD License text as
   described in Section 4.e of the Trust Legal Provisions and are
   provided without warranty as described in the Revised BSD License.

Table of Contents

   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   3
     1.1.  The Need for Increased Entropy  . . . . . . . . . . . . .   3
     1.2.  Requirements Additional Embedded Data . . . . . . . . . .   3
     1.3.  A better UUID sub-typing system . . . . . . . . . . . . .   4
   2.  Conventions and Definitions . . . . . . . . . . . . . . . . .   4
     2.1.  Notational Conventions  . . . . . . . . . . . . . . . . .   4
   3.  UUID Long Format  . . . . . . . . . . . . . . . . . . . . . .   5
     3.1.  Variant Field . . . . . . . . . . . . . . . . . . . . . .   7
     3.2.  Sub-Typing Logic and Encoding Block . . . . . . . . . . .   8
     3.3.  Sub-Variants  . . . . . . . . . . . . . . . . . . . . . .   9
   4.  UUID Long Algorithms  . . . . . . . . . . . . . . . . . . . .   9
     4.1.  Sub-Variant 0 . . . . . . . . . . . . . . . . . . . . . .  10
       4.1.1.  sv0a8 . . . . . . . . . . . . . . . . . . . . . . . .  11
     4.2.  Sub-Variant 1 . . . . . . . . . . . . . . . . . . . . . .  11
       4.2.1.  sv1a4 . . . . . . . . . . . . . . . . . . . . . . . .  12
     4.3.  Sub-Variant 2 . . . . . . . . . . . . . . . . . . . . . .  12
       4.3.1.  sv2a1 . . . . . . . . . . . . . . . . . . . . . . . .  13
       4.3.2.  sv2a6 . . . . . . . . . . . . . . . . . . . . . . . .  14
       4.3.3.  sv2a7 . . . . . . . . . . . . . . . . . . . . . . . .  14
     4.4.  Sub-Variant 3 . . . . . . . . . . . . . . . . . . . . . .  15



Davis                   Expires 28 February 2025                [Page 2]

Internet-Draft                  UUID Long                    August 2024


       4.4.1.  sv3a5 . . . . . . . . . . . . . . . . . . . . . . . .  17
       4.4.2.  sv3a16 - sv3a23 . . . . . . . . . . . . . . . . . . .  17
   5.  Compatibility with 128 Bit UUIDs  . . . . . . . . . . . . . .  18
   6.  Security Considerations . . . . . . . . . . . . . . . . . . .  18
   7.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  19
   8.  References  . . . . . . . . . . . . . . . . . . . . . . . . .  19
     8.1.  Normative References  . . . . . . . . . . . . . . . . . .  19
     8.2.  Informative References  . . . . . . . . . . . . . . . . .  19
   Appendix A.  Changelog  . . . . . . . . . . . . . . . . . . . . .  19
   Appendix B.  Test Vectors . . . . . . . . . . . . . . . . . . . .  19
     B.1.  Example sv1a4 values  . . . . . . . . . . . . . . . . . .  20
     B.2.  Example sv3a5 Value . . . . . . . . . . . . . . . . . . .  20
     B.3.  Example sv3a17 Value  . . . . . . . . . . . . . . . . . .  20
   Author's Address  . . . . . . . . . . . . . . . . . . . . . . . .  21

1.  Introduction

   There are a few main driving factors behind extending UUID beyond 128
   bits covered by the next sections.

1.1.  The Need for Increased Entropy

   While existing UUID formats provide sufficient entropy for most use
   cases; there exists scenarios where even more entropy is required to
   further reduce collision probabilities or guessability.

   Further, while creating UUIDv7 during the draft phases of RFC9562, a
   common discussion point surrounded the number of bits allocated to
   entropy vs the number of bits allocated to the embedded timestamp.
   The 128 bit limits on UUID created a situation where the community
   had to balance timestamp granularity vs entropy.  This resulted in
   "sliding" bits one way or other trying to find a happy medium.  While
   in the end a fine balance was achieved; the entire problem could have
   been avoided if there were more bits available to the UUID format.

   With the additional length added by UUID Long; an application can
   generate a UUID with certainty that it is truly "unique across space
   and time".

1.2.  Requirements Additional Embedded Data

   Some implementations require more than 128 bits to properly embed all
   of the application specific data they require for a given UUID
   algorithm.  Some examples include database metadata like entity
   types, checksum values, shard/partition identifiers, and even node
   identifiers for distributed UUID generation.





Davis                   Expires 28 February 2025                [Page 3]

Internet-Draft                  UUID Long                    August 2024


   UUID Long provides ample bit space for an algorithm to properly embed
   all of the items required for the application logic to function.

1.3.  A better UUID sub-typing system

   128 bit UUIDs within the "OSF DCE / IETF" variant space are limited
   to 16 versions.  This version limit artificially inhibits innovation
   of new UUID algorithms (a problem partly solved by UUIDv8).

   This drawback of the "OSF DCE / IETF" variant space was observed
   while working on [RFC9562], in particular to future name-based UUID
   layouts that replace "UUIDv3" and "UUIDv5".  With the number of
   hashing algorithms available and the possibility that at any point
   one may be deprecated; there was little chance of getting consensus
   on leveraging one of the few remaining versions for such an
   algorithm.

   With UUID Long, as per section Section 3.2, there is ample room for
   future UUID Long Algorithms.

2.  Conventions and Definitions

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in
   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all
   capitals, as shown here.

2.1.  Notational Conventions

   "UUID Long" generally references any variable length UUID longer than
   128 bits while "UUID Short" references fixed-length 128-bit UUIDs in
   the prose of this document.

   Field and Bit Layout in this document use a custom format borrowed
   from [RFC9000] rather than those featured in [RFC9562].  The purpose
   of this format is to summarize, not define, protocol elements.  Prose
   defines the complete semantics and details of structures.

   Layouts items are named and then followed by a list of fields
   surrounded by a pair of matching braces.  Each field in this list is
   separated by commas.

   Individual fields include length information, plus indications about
   fixed value, optionality, or repetitions.  Individual fields use the
   following notational conventions, with all lengths in bits:

   x (A):  Indicates that x is A bits long



Davis                   Expires 28 February 2025                [Page 4]

Internet-Draft                  UUID Long                    August 2024


   x (A..B):  Indicates that x can be any length from A to B; A can be
      omitted to indicate a minimum of zero bits, and B can be omitted
      to indicate no set upper limit; values in this format always end
      on a byte boundary

   x (L) = C:  Indicates that x has a fixed value of C; the length of x
      is described by L, which can use any of the length forms above

   This document uses network byte order (that is, big endian) values.
   Fields are placed starting from the high-order bits of each byte.

   By convention, individual fields reference a complex field by using
   the name of the complex field.

   Figure 1 provides an example:

   Example Structure {
     One-bit Field (1),
     7-bit Field with Fixed Value (7) = 61,
     Arbitrary-Length Field (..),
     Variable-Length Field (8..24),
     Field With Minimum Length (16..),
     Field With Maximum Length (..128),
   }

                          Figure 1: Example Format

3.  UUID Long Format

   At the core UUID Long features the same base characteristics as
   [RFC9562], Section 4 featured in UUID Short.  UUID Long may be
   represented in all of the same ways as you would expect with a UUID
   (e.g text, integer, binary, UUID URN, etc.)

   The UUID Long Encoding Block starts at bit 129 with the actual UUID
   Long Data starting at Bit 177.  The 48 bit UUID Long Encoding block
   and UUID Long Data are separated by the dash character "-" in the
   textual representation of UUID Long.

   This separation allows at-a-glance readability around the encoding
   block and separation from the variable-length UUID Long Data.

   The generalized layout of UUID Long is Figure 2 and the UUID Encoding
   Block is found in Figure 3.







Davis                   Expires 28 February 2025                [Page 5]

Internet-Draft                  UUID Long                    August 2024


   UUID Long Structure {
     UUID Short Part A (64),
     UUID Variant (4) = F,
     UUID Short Part B (60),
     UUID Long Encoding Block (48),
     UUID Long Data (8..16777215),
   }

              Figure 2: Example UUID Long Bit and Field Layout

   UUID Long Encoding Block {
     Sub-Variant Encoding (8),
     Algorithm Encoding (16),
     UUID Long Data Length Descriptor (24)
   }

      Figure 3: Example UUID Long Encoding Block Bit and Field Layout

   Further, the base UUID Short string format with hex and dashes is
   also found in the string format of UUID Long.  Including this in the
   base syntax ensures backwards compatibility as per Section 5.  The
   UUID Long string representation is defined by Figure 4 and Table 1.

   xxxxxxxx-xxxx-xxxx-Fxxx-xxxxxxxxxxxx-SVAAAALLLLLL-yy...zz

                  Figure 4: UUID Long Field Layout in Hex

























Davis                   Expires 28 February 2025                [Page 6]

Internet-Draft                  UUID Long                    August 2024


    +=========+===========================================+==========+
    | ID      | Description                               | Bits     |
    +=========+===========================================+==========+
    | x       | Short UUID Bits                           | 124      |
    +---------+-------------------------------------------+----------+
    | F       | Frozen Variant byte (for backwards        | 4        |
    |         | compatibility).  See section Section 3.1. |          |
    +---------+-------------------------------------------+----------+
    | SV      | One Byte Sub-Variant with 256 possible    | 8        |
    |         | values                                    |          |
    +---------+-------------------------------------------+----------+
    | AAAA    | Two Byte Algorithm with 65,536 possible   | 16       |
    |         | values                                    |          |
    +---------+-------------------------------------------+----------+
    | LLLLLL  | Three Byte length descriptor of           | 24       |
    |         | 16,777,215 max length for UUID Long data  |          |
    +---------+-------------------------------------------+----------+
    | yy...zz | Variable length UUID Long Data with       | Variable |
    |         | length described by LLLLLL.  Minimum one  |          |
    |         | byte, maximum 2,097,151 bytes             |          |
    +---------+-------------------------------------------+----------+

               Table 1: UUID Long String Layout Descriptors

   A properly constructed UUID Long value will be, at a minimum, 176
   bits or 22 octets.  The maximum value for a UUID Long is computed as
   UUID Short Length (128) + Long Encoding Block (48) + Maximum UUID
   Long Data Length (16,777,215) which is 16,777,391 bits (2,097,173
   octets)

   Applications MUST ensure that UUID Long values leverage natural byte
   boundaries and pad the least significant, right-most bits where
   required to achieve a proper byte boundary.

3.1.  Variant Field

   This section updates [RFC9562], Section 4.1 to split the unused final
   variant of "111x" into two variants as described by the Table 2
   table.  Splitting the final variant space ensures that the "E"
   variant may be used by future definitions while the "F" variant is
   used to signal a UUID Long Variant.  These "F"rozen variant bits are
   set to all 1's (b1111).









Davis                   Expires 28 February 2025                [Page 7]

Internet-Draft                  UUID Long                    August 2024


    +======+======+======+======+=========+==========================+
    | Msb0 | Msb1 | Msb2 | Msb3 | Variant | Description              |
    +======+======+======+======+=========+==========================+
    | 1    | 1    | 1    | 0    | E       | Reserved for future      |
    |      |      |      |      |         | definition.              |
    +------+------+------+------+---------+--------------------------+
    | 1    | 1    | 1    | 1    | F       | The variant used by UUID |
    |      |      |      |      |         | Long in this document.   |
    |      |      |      |      |         | Also includes Max UUID   |
    |      |      |      |      |         | as per [RFC9562],        |
    |      |      |      |      |         | Section 5.10.            |
    +------+------+------+------+---------+--------------------------+

                      Table 2: UUID Variant Updates

   UUID Long algorithms featuring the frozen Variant F MUST use the sub-
   typing logic and encoding block described in Section 3.2.

3.2.  Sub-Typing Logic and Encoding Block

   UUID Long does not re-use the "version" nomenclature (or bit
   positions) from [RFC9562].  This serves to helps an implementations
   easily distinguish 128 bit or 128+ bit UUIDs in text and provide an
   opportunity for defining a better sub-typing system within this new
   variant space.

   Note that "UUIDv4" or "UUID Version 4" is usually used to reference
   an UUID algorithm as specified by [RFC9562], Section 5.4 and do not
   represent UUID Long algorithms in this document.

   UUID Long instead moves the sub-typing logic to a new 6 byte UUID
   Long Encoding Block placed immediately after the 128th bit in the
   original UUID layout.  This move of the sub-typing bit ensures the
   first 64 bits of the UUID Long are uninterrupted up to the frozen
   Variant bits.  This move also allows UUID Long to avoid the 4 bit
   version space that comes with drawbacks as alluded to in Section 1.3.

   The first 3 bytes of the UUID Long Encoding Block features sub-typing
   system with two levels of hierarchy.  The first is a "Sub-Variant"
   abbreviated "sv" which indicates the grouping of UUID Long algorithm
   types.  The second level of UUID Long sub-typing is defined as simply
   the "algorithm" which can be abbreviated "a".  The Sub-Variant plus
   Algorithm (SV+A) serve as the identity behind a particular a UUID
   Long value.

   With this in mind "Sub-Variant 0, Algorithm 4" can be expressed as
   "sv0a4" or "UUIDsv0a4" throughout this document.




Davis                   Expires 28 February 2025                [Page 8]

Internet-Draft                  UUID Long                    August 2024


   The final 3 bytes of the UUID Long Encoding Block includes a
   descriptor for the length of the variable-length UUID Long data which
   can be used by applications in order to understand where a UUID Long
   value ends.

   The full 6 byte UUID Encoding block can be observed in Figure 3 or
   Figure 4 and described succinctly in Table 1.

3.3.  Sub-Variants

   UUID Long defines four starting sub-variant groupings as defined by
   Table 3.

            +================+================================+
            | Sub-Variant ID | Description                    |
            +================+================================+
            | sv0            | Experimental/Custom Algorithms |
            +----------------+--------------------------------+
            | sv1            | Random Based Algorithms        |
            +----------------+--------------------------------+
            | sv2            | Time Based Algorithms          |
            +----------------+--------------------------------+
            | sv3            | Hash-based Algorithms          |
            +----------------+--------------------------------+
            | sv4-sv255      | Reserved for future algorithm  |
            |                | groupings as required          |
            +----------------+--------------------------------+

                      Table 3: UUID Long Sub-Variants

   Future sub-variants in the space (sv4-sv255) can be allocated where a
   grouping of algorithms is required; but if a current sub-variant is
   applicable for a new algorithm, the new algorithm should be grouped
   under a given sub-variant.

   The four starting sub-variant groupings mirror the four generic types
   of UUID algorithms observed in [RFC9562].

4.  UUID Long Algorithms

   As mentioned in Section 3.2, UUID Long Algorithms are grouped by at
   the Sub-Variant level.

   UUID Long first maps the [RFC9562] versions to algorithms in the
   appropriate sub-variant algorithm space.  The sub-variant algorithm
   identifier has been 'smeared' for ease understanding when referencing
   the old values.  For example: "UUIDv4 == UUIDsv1a4" and "UUIDv7 ==
   UUIDsv2a7" where the final number in each abbreviation matches.



Davis                   Expires 28 February 2025                [Page 9]

Internet-Draft                  UUID Long                    August 2024


   The first 16 sub-variant algorithm values (a0-a15) in each sub-
   variant space are reserved for matching the appropriate [RFC9562]
   versions.  This ensures that a future IETF spec can define both a
   UUID Short Version and UUID Long sub-variant algorithm that line up
   nicely to each other.  With 65,536 possible sub-variant algorithms in
   each of the 256 sub-variant spaces; 16 reserved sub-variant algorithm
   identifiers should be no problem.

   When the time comes that all 16 [RFC9562] versions have allocated to
   their appropriate UUID Long SV+A IDs, or are no longer in need of the
   mapping space; outstanding sub-variant algorithm identifiers MAY be
   used by future UUID Long specifications.

   Other UUID sub-types that existing in other variant spaces MAY
   leverage unused sub-variant algorithm identifiers, starting at a16,
   for UUID Long versions of the existing algorithms.

   Generally speaking for sub-variant algorithms based on the RFC9562
   versions; there are two main areas that need to be described:

   *  How to leverage the new UUID Long bits.
   *  Define if the RFC9562 version bit handling.

   The following sections illustrates the current sub-variant algorithm
   mappings for UUID Long along with the methods for generating a UUID
   Long value for a given sub-variant algorithm.

   For all algorithms the following two statements apply, even if they
   are based on an RFC9562-based algorithm.

   *  The Variant bits are always overwritten to "F" as per Section 3.1.
   *  The UUID Long Encoding Block is encoded with the sub-variant id,
      algorithm id and long data length descriptor as per Figure 3.

4.1.  Sub-Variant 0

   Algorithm Identifiers in this sub-variant space SHOULD be used for
   custom, experimental or vendor-specific use cases.  UUIDv8 has been
   mapped to UUIDsv0v8 in this document and is the only current
   algorithm in this space defined by Table 4.

   Vendor's are encouraged to use this space for testing and
   experimental algorithms before finalization into another sub-variant
   algorithm identifier.  At which point the Algorithm Identifier in
   this sub-variant can be released for continued use.






Davis                   Expires 28 February 2025               [Page 10]

Internet-Draft                  UUID Long                    August 2024


   +=======+==============+========+=================+=================+
   | SV ID | Algorithm    | Name   | 9562 Version    | Algorithm       |
   |       | ID           |        | (if applicable) | Definition Link |
   +=======+==============+========+=================+=================+
   | sv0   | a8           | Custom | UUIDv8          | Section 4.1.1   |
   +-------+--------------+--------+-----------------+-----------------+

                     Table 4: Sub-Variant 0 Algorithms

4.1.1.  sv0a8

   sv0a8 is based on UUIDv8 from [RFC9562], Section 5.8 with the
   following deltas:

   *  UUID Long Data can be leveraged as a new "custom_d" field of
      arbitrary size within the UUID Long data as shown in Figure 5.
      The length of this new data is calculated and inserted into the
      UUID Long Encoding Block.
   *  The version behavior does not need to remain the same as
      [RFC9562], Section 4.2 and can be set to whatever an
      implementation desires.

   UUIDsv0a8 Structure {
     custom_a (48),
     9562 Version (4),
     custom_b (12),
     UUID Variant (4) = F,
     custom_c (60),
     UUID Long Encoding Block (48),
     custom_d (8..16777215),
   }

                Figure 5: Example sv0a8 Bit and Field Layout

   Note that where possible, for experimental use cases, implementation
   are encouraged to apply for a sub-variant algorithm for their UUID
   Long Algorithm.

   TODO Link to process section

4.2.  Sub-Variant 1

   Algorithm Identifiers in this sub-variant space MUST be related to
   random, pseudorandom, or other similar methods of generating UUID
   Long values.

   UUIDv4 has been mapped to UUIDsv1a4 in this document and is the only
   current algorithm in this space defined by Table 5.



Davis                   Expires 28 February 2025               [Page 11]

Internet-Draft                  UUID Long                    August 2024


   +=======+==============+========+=================+=================+
   | SV ID | Algorithm    | Name   | 9562 Version    | Algorithm       |
   |       | ID           |        | (if applicable) | Definition Link |
   +=======+==============+========+=================+=================+
   | sv1   | a4           | Random | UUIDv4          | Section 4.2.1   |
   +-------+--------------+--------+-----------------+-----------------+

                     Table 5: Sub-Variant 1 Algorithms

4.2.1.  sv1a4

   sv1a4 is based on UUIDv4 from [RFC9562], Section 5.4 with the
   following deltas:

   *  UUID Long Data can be leveraged as a new "random_d" field of
      arbitrary size within the UUID Long data as shown in Figure 6.
      The length of this new data is calculated and inserted into the
      UUID Long Encoding Block.
   *  The version behavior does not need to remain the same as
      [RFC9562], Section 4.2 and these 4 version bits MAY also be
      randomized.

   UUIDsv1a4 Structure {
     random_a (48),
     9562 Version (4),
     random_b (12),
     UUID Variant (4) = F,
     random_c (60),
     UUID Long Encoding Block (48),
     random_d (8..16777215),
   }

                Figure 6: Example sv1a4 Bit and Field Layout

   Examples of UUIDsv1a4 can be seen in Appendix B.1.

4.3.  Sub-Variant 2

   Algorithm Identifiers in this sub-variant space MUST be related to
   UUIDs which feature timestamps.

   UUIDv1, UUIDv6 and UUIDv7 have been mapped to UUIDsv2a1, UUIDsv2a6,
   UUIDsv2a7 where required as per Table 6.








Davis                   Expires 28 February 2025               [Page 12]

Internet-Draft                  UUID Long                    August 2024


   +=====+===========+============+=================+=================+
   | SV  | Algorithm | Name       | 9562 Version    | Algorithm       |
   | ID  | ID        |            | (if applicable) | Definition Link |
   +=====+===========+============+=================+=================+
   | sv2 | a1        | Gregorian  | UUIDv1          | Section 4.3.1   |
   |     |           | Time-based |                 |                 |
   +-----+-----------+------------+-----------------+-----------------+
   | sv2 | a6        | Reordered  | UUIDv6          | Section 4.3.2   |
   |     |           | Gregorian  |                 |                 |
   |     |           | Time-based |                 |                 |
   +-----+-----------+------------+-----------------+-----------------+
   | sv2 | a7        | Unix Time- | UUIDv7          | Section 4.3.3   |
   |     |           | based (MS) |                 |                 |
   +-----+-----------+------------+-----------------+-----------------+

                    Table 6: Sub-Variant 2 Algorithms

4.3.1.  sv2a1

   sv2a1 is based on UUIDv1 from [RFC9562], Section 5.1 with the
   following deltas:

   *  UUID Long Data can be leveraged to as an "extended_node" field
      within the UUID Long data as shown in Figure 7.  The length of
      this new data is calculated and inserted into the UUID Long
      Encoding Block.
   *  The node value MAY feature IEEE 802 MAC address and random data of
      arbitrary size or be fully randomized using portions of the
      original node bits and variable-length UUID Long data.
   *  The version behavior SHOULD remain the same as [RFC9562],
      Section 4.2, the version bits MAY also be randomized since this
      does not effect the sortability of this algorithm.

   UUIDsv2a1 Structure {
     time_low (32),
     time_mid (16),
     9562 Version (4),
     time_high (12),
     UUID Variant (4) = F,
     clock_seq (14),
     node (48),
     UUID Long Encoding Block (48),
     extended_node (8..16777215),
   }

                Figure 7: Example sv2a1 Bit and Field Layout





Davis                   Expires 28 February 2025               [Page 13]

Internet-Draft                  UUID Long                    August 2024


4.3.2.  sv2a6

   sv2a6 is based on UUIDv6 from [RFC9562], Section 5.6 with the
   following deltas:

   *  UUID Long Data can be leveraged to as an "extended_node" field
      within the UUID Long data as shown in Figure 8.  The length of
      this new data is calculated and inserted into the UUID Long
      Encoding Block.
   *  The node value MAY feature IEEE 802 MAC address and random data of
      arbitrary size or be fully randomized using portions of the
      original node bits and variable-length UUID Long data.
   *  The version behavior MUST remain the same as [RFC9562],
      Section 4.2 to ensures proper sortability which is a key feature
      of this UUID's algorithm.

   UUIDsv2a6 Structure {
     time_high (32),
     time_mid (16),
     9562 Version (4) = 6,
     time_low (12),
     UUID Variant (4) = F,
     clock_seq (14),
     node (48),
     UUID Long Encoding Block (48),
     extended_node (8..16777215),
   }

                Figure 8: Example sv2a6 Bit and Field Layout

4.3.3.  sv2a7

   sv2a7 is based on UUIDv7 [RFC9562], Section 5.7 with the following
   deltas:

   *  UUID Long Data can be leveraged to as an "rand_c" field within the
      UUID Long data as shown in Figure 9.  The length of this new data
      is calculated and inserted into the UUID Long Encoding Block.
   *  The version behavior MUST remain the same as [RFC9562],
      Section 4.2 to ensures proper sortability which is a key feature
      of this UUID's algorithm.










Davis                   Expires 28 February 2025               [Page 14]

Internet-Draft                  UUID Long                    August 2024


   UUIDsv2a7 Structure {
     unix_ts_ms (48),
     9562 Version (4) = 7,
     rand_a (12),
     UUID Variant (4) = F,
     rand_b (60),
     UUID Long Encoding Block (48),
     rand_c (8..16777215),
   }

                Figure 9: Example sv2a7 Bit and Field Layout

4.4.  Sub-Variant 3

   Algorithm Identifiers in this sub-variant space MUST be related to
   hash-based UUIDs computed using "names" and "namespaces" as defined
   by [RFC9562], Section 6.5 UUIDv5 has been mapped to UUIDsv3a5 while
   new hashing protocols utilize algorithms a16 through a27.  (TODO:
   CITE NIST Docs)
































Davis                   Expires 28 February 2025               [Page 15]

Internet-Draft                  UUID Long                    August 2024


   +=====+===========+=============+=================+=================+
   | SV  | Algorithm | Name        | 9562 Version    | Algorithm       |
   | ID  | ID        |             | (if applicable) | Definition      |
   |     |           |             |                 | Link            |
   +=====+===========+=============+=================+=================+
   | sv3 | a5        | SHA-1       | UUIDv5          | Section         |
   |     |           |             |                 | 4.4.1           |
   +-----+-----------+-------------+-----------------+-----------------+
   | sv3 | a16       | SHA-224     |                 | Section         |
   |     |           |             |                 | 4.4.2           |
   +-----+-----------+-------------+-----------------+-----------------+
   | sv3 | a17       | SHA-256     |                 | Section         |
   |     |           |             |                 | 4.4.2           |
   +-----+-----------+-------------+-----------------+-----------------+
   | sv3 | a18       | SHA-384     |                 | Section         |
   |     |           |             |                 | 4.4.2           |
   +-----+-----------+-------------+-----------------+-----------------+
   | sv3 | a19       | SHA-512     |                 | Section         |
   |     |           |             |                 | 4.4.2           |
   +-----+-----------+-------------+-----------------+-----------------+
   | sv3 | a20       | SHA-512/224 |                 | Section         |
   |     |           |             |                 | 4.4.2           |
   +-----+-----------+-------------+-----------------+-----------------+
   | sv3 | a21       | SHA-512/256 |                 | Section         |
   |     |           |             |                 | 4.4.2           |
   +-----+-----------+-------------+-----------------+-----------------+
   | sv3 | a22       | SHA3-224    |                 | Section         |
   |     |           |             |                 | 4.4.2           |
   +-----+-----------+-------------+-----------------+-----------------+
   | sv3 | a23       | SHA3-256    |                 | Section         |
   |     |           |             |                 | 4.4.2           |
   +-----+-----------+-------------+-----------------+-----------------+
   | sv3 | a24       | SHA3-384    |                 | Section         |
   |     |           |             |                 | 4.4.2           |
   +-----+-----------+-------------+-----------------+-----------------+
   | sv3 | a25       | SHA3-512    |                 | Section         |
   |     |           |             |                 | 4.4.2           |
   +-----+-----------+-------------+-----------------+-----------------+
   | sv3 | a26       | SHAKE128    |                 | Section         |
   |     |           |             |                 | 4.4.2           |
   +-----+-----------+-------------+-----------------+-----------------+
   | sv3 | a27       | SHAKE256    |                 | Section         |
   |     |           |             |                 | 4.4.2           |
   +-----+-----------+-------------+-----------------+-----------------+

                     Table 7: Sub-Variant 3 Algorithms





Davis                   Expires 28 February 2025               [Page 16]

Internet-Draft                  UUID Long                    August 2024


   Note that UUIDv3 has not been mapped to UUIDsv3a3 because the current
   MD5-based algorithm from [RFC9562], Section 5.3 does not have any
   requirements for bits past 128.  Thus there is no need for a UUID
   Long equivalent of this algorithm.

4.4.1.  sv3a5

   sv3a5 is based on UUIDv5 from [RFC9562], Section 5.5 with the
   following deltas:

   *  The original algorithm requires that parts of the SHA-1 hash be
      truncated to fit the 128 bit layout however with UUID Long these
      extra bits can be embedded into the UUID Long Data as
      "sha1_discard" seen in Figure 10.  The length of this discarded
      data is calculated and inserted into the UUID Long Encoding Block.
   *  The version MUST NOT remain the same as [RFC9562], Section 4.2.
      As a result the bits that would have been overwritten to a hard
      coded "5" are now left as the original portions of the hash.

   UUIDsv3a5 Structure {
     sha1_high (48),
     9562 Version (4),
     sha1_mid (12),
     UUID Variant (4) = F,
     sha1_low (60),
     UUID Long Encoding Block (48),
     sha1_discard (8..16777215),
   }

               Figure 10: Example sv3a5 Bit and Field Layout

   An Example of UUIDsv3a5 can be seen in Appendix B.2.

4.4.2.  sv3a16 - sv3a23

   sv3a16 - sv3a23 describe Name-Based UUID generation using new hashing
   algorithms.  From an operational standpoint the same fields are
   described for all of these algorithms.  This is shown in Figure 11.

   The algorithm and creation of these UUID Long values is the same as
   [RFC9562], Section 5.5 with the following deltas:

   *  The desired hash algorithm is used in place of SHA-1.
   *  The 9562 Version is not used and those 4 bits retain their value
      from the hash.
   *  The bits beyond 128 are placed in "hash_low" with the length
      calculated and inserted into the UUID Long Encoding Block.




Davis                   Expires 28 February 2025               [Page 17]

Internet-Draft                  UUID Long                    August 2024


   UUID Long Hash-Based Structure {
     hash_high (64),
     UUID Variant (4) = F,
     hash_middle (60),
     UUID Long Encoding Block (48),
     hash_low (8..16777215),
   }

        Figure 11: Example UUID Long Hash-Based Bit and Field Layout

   Example of UUIDsv3a17, using SHA-256, can be seen in Appendix B.3.

5.  Compatibility with 128 Bit UUIDs

   Since the first 128 bits are a valid UUID Short, if some device does
   not understand UUID Long they can read the first 128 bit and still
   gleam a valid 128 bit UUID value.  Though some system may have a
   problem reading or accepting the F Variant; this approach ensures
   that a given UUID Long value can be easily transposed into a smaller
   value where required.

   Note that the version bit-space is not a requirement in UUID Long
   thus some UUID sub-variant algorithms may have varying data at this
   position.  The bits still exist so for systems that do not read the
   variant bit first, they may see inconsistent results if trying to
   read only the version or version and then variant.

6.  Security Considerations

   UUID Long shared many of the same security considerations as
   [RFC9562].  The main security consideration with UUID Long is the
   maximum length of data and possible buffer overflows which lead to
   other vulnerabilities.  Implementations that only expect 128 bit
   UUIDs should not read beyond 128 bits.

   Implementations that plan to work with UUID Long values should use
   the UUID Long Data Descriptor field within the UUID Long Encoding
   block to gleam the total length of the UUID Long Data Field.
   Implementations should also program safeguards as to not read more
   data than is available in memory.  For example, setting an arbitrary
   maximum on the amount of UUID Long data that is parsed.

   By default the UUID Long value (and UUID short) do not feature any
   hash/signature method.  An attacker could modify the UUID Long Data
   Length Descriptor bits and include new data in an attempt to force
   some buffer overflow condition or append data that was not part of
   the original algorithm.  An algorithm MAY choose create a hash/
   digital signature on the final UUID Long value and provide this hash



Davis                   Expires 28 February 2025               [Page 18]

Internet-Draft                  UUID Long                    August 2024


   to a peer in order to provide some levels data integrity.  Further,
   where possible introspection into the UUID is discouraged as per
   [RFC9562], Section 6.12.

7.  IANA Considerations

   TODO: IANA when things are finalized.  Things like add sub-variant
   algorithms to sub-types section of UUID registry.

8.  References

8.1.  Normative References

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://www.rfc-editor.org/rfc/rfc2119>.

   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC
              2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174,
              May 2017, <https://www.rfc-editor.org/rfc/rfc8174>.

   [RFC9562]  Davis, K., Peabody, B., and P. Leach, "Universally Unique
              IDentifiers (UUIDs)", RFC 9562, DOI 10.17487/RFC9562, May
              2024, <https://www.rfc-editor.org/rfc/rfc9562>.

8.2.  Informative References

   [RFC9000]  Iyengar, J., Ed. and M. Thomson, Ed., "QUIC: A UDP-Based
              Multiplexed and Secure Transport", RFC 9000,
              DOI 10.17487/RFC9000, May 2021,
              <https://www.rfc-editor.org/rfc/rfc9000>.

Appendix A.  Changelog

   This section is to be removed before publishing as an RFC.

   draft-00:
      *  Initial Release

Appendix B.  Test Vectors

   Due to the variable length nature of the UUID Long Data field there
   could be an infinite number of test vectors.  The sections below
   attempt to summarize the key points of the sub-variant algorithms as
   described by the body of this document.





Davis                   Expires 28 February 2025               [Page 19]

Internet-Draft                  UUID Long                    August 2024


B.1.  Example sv1a4 values

   +=======+======+======+==========================================================================+
   |DOC    |Type  |Random|Example                                                                   |
   |       |      |Bits  |                                                                          |
   +=======+======+======+==========================================================================+
   |RFC9562|UUIDv4|122   |73e94fe0-e951-4153-aaf3-50e4e6089d9d                                      |
   +-------+------+------+--------------------------------------------------------------------------+
   |DRAFT  |sv1a4 |160   |81783312-54db-bef3-f722-2515c8f3aceb-010004000022-2072a4623               |
   +-------+------+------+--------------------------------------------------------------------------+
   |DRAFT  |sv1a4 |192   |b6debb20-db1e-cdc7-f65f-c266fd5e25e9-010004000044-b1150e08ab9e81a11       |
   +-------+------+------+--------------------------------------------------------------------------+
   |DRAFT  |sv1a4 |256   |d0fda74d-                                                                 |
   |       |      |      |59a7-76c9-fd30-587ea76c99e9-010004000083-63f93f97b7b47cc5c853ce09a87ded629|
   +-------+------+------+--------------------------------------------------------------------------+

                                  Table 8

B.2.  Example sv3a5 Value

   Namespace (DNS):  6ba7b810-9dad-11d1-80b4-00c04fd430c8
   Name:             www.example.com
   ----------------------------------------------------------
   SHA-1: 2ed6657de927468b55e12665a8aea6a22dee3e35

   A: 2ed6657d-e927-468b-55e1-2665a8aea6a2-2dee3e35
   B: xxxxxxxx-xxxx-xxxx-Fxxx-xxxxxxxxxxxx
   C: 2ed6657d-e927-468b-f5e1-2665a8aea6a2
   D:                                     -2dee3e35
   E: 2ed6657d-e927-468b-f5e1-2665a8aea6a2-03000500001e
   F: 2ed6657d-e927-468b-f5e1-2665a8aea6a2-03000500001e-2dee3e35

   *  Line A details the full SHA-1 as a hexadecimal value with the
      dashes inserted.
   *  Line B details the F variant hexadecimal positions, which must be
      overwritten.
   *  Line C details the final value after the variant has been
      overwritten.
   *  Line D details the leftover values from the original SHA-1
      computation (Note that these have a length of 30 bits)
   *  Line E details adding the UUID Long encoding block of Sub-Variant
      3, and algorithm 5 (RFC 9562's version 5), and long data length of
      30 bits as hex with leading 0s included.
   *  Line F details the leftover values appended to form the full UUID
      Long of form sv3a5.

B.3.  Example sv3a17 Value




Davis                   Expires 28 February 2025               [Page 20]

Internet-Draft                  UUID Long                    August 2024


Namespace (DNS): 6ba7b810-9dad-11d1-80b4-00c04fd430c8
Name:            www.example.com
----------------------------------------------------------------
SHA-256: 5c146b143c524afd938a375d0df1fbf6fe12a66b645f72f6158759387e51f3c8

A: 5c146b14-3c52-4afd-938a-375d0df1fbf6-fe12a66b645f72f6158759387e51f3c8
B: xxxxxxxx-xxxx-xxxx-Fxxx-xxxxxxxxxxxx
C: 5c146b14-3c52-4afd-f38a-375d0df1fbf6
D:                                     -fe12a66b645f72f6158759387e51f3c8
E: 5c146b14-3c52-4afd-f38a-375d0df1fbf6-030011000080
F: 5c146b14-3c52-4afd-f38a-375d0df1fbf6-030011000080-fe12a66b645f72f6158759387e51f3c8

   *  Line A details the full SHA-256 as a hexadecimal value with the
      dashes inserted.
   *  Line B details the F variant hexadecimal positions, which must be
      overwritten.
   *  Line C details the final value after the variant has been
      overwritten.
   *  Line D details the leftover values from the original SHA-256
      computation (Note that these have a length of 128 bits)
   *  Line E details adding the UUID Long encoding block of Sub-Variant
      3, and algorithm 7 (SHA-256), and long data length of 128 bits as
      hex with leading 0s included.
   *  Line F details the leftover values appended to form the full UUID
      Long of form sv3a17.

Author's Address

   Kyzer R. Davis
   Cisco Systems
   Email: kydavis@cisco.com




















Davis                   Expires 28 February 2025               [Page 21]
